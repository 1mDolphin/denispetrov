import "./chunk-EQCVQC35.js";

// node_modules/tornis/src/tornis.js
var isSSR = typeof window === "undefined";
function throttled(delay, fn) {
  let lastCall = 0;
  return function(...args) {
    const now = (/* @__PURE__ */ new Date()).getTime();
    if (now - lastCall < delay) {
      return;
    }
    lastCall = now;
    return fn(...args);
  };
}
function getMean(arr) {
  return Math.floor(arr.reduce((acc, curr) => {
    return acc + curr;
  }, 0) / arr.length);
}
var Tornis = class {
  // set a whole load of initial values
  constructor() {
    if (isSSR) return;
    this.lastX = 0;
    this.lastY = 0;
    this.lastWidth = window.innerWidth;
    this.lastHeight = window.innerHeight;
    this.lastMouseX = 0;
    this.lastMouseY = 0;
    this.lastWindowX = window.screenX;
    this.lastWindowY = window.screenY;
    this.lastAlpha = 0;
    this.lastBeta = 0;
    this.lastGamma = 0;
    this.currAlpha = 0;
    this.currBeta = 0;
    this.currGamma = 0;
    this.scrollHeight = document.body.scrollHeight;
    this.scrollChange = false;
    this.sizeChange = false;
    this.mouseChange = false;
    this.positionChange = false;
    this.orientationChange = false;
    this.devicePixelRatioChange = false;
    this.currX = 0;
    this.currY = 0;
    this.currWidth = window.innerWidth;
    this.currHeight = window.innerHeight;
    this.currMouseX = 0;
    this.currMouseY = 0;
    this.currWindowX = 0;
    this.currDevicePixelRatio = this.lastDevicePixelRatio = Math.max(window.devicePixelRatio || 1, 1);
    this.mouseXVelocity = [];
    this.mouseYVelocity = [];
    this.lastMouseXVelocity = 0;
    this.lastMouseYVelocity = 0;
    this.windowXVelocity = [];
    this.windowYVelocity = [];
    this.lastWindowXVelocity = 0;
    this.lastWindowYVelocity = 0;
    this.updating = false;
    this.callbacks = [];
    this.update = this.update.bind(this);
    this.handleResize = this.handleResize.bind(this);
    this.handleMouse = this.handleMouse.bind(this);
    this.handleOrientation = this.handleOrientation.bind(this);
    this.recalibrateOrientation = this.recalibrateOrientation.bind(this);
    this.formatData = this.formatData.bind(this);
    this.watch = this.watch.bind(this);
    this.unwatch = this.unwatch.bind(this);
    this.handleResize = throttled(110, this.handleResize);
    this.handleMouse = throttled(75, this.handleMouse);
    window.addEventListener("resize", this.handleResize);
    window.addEventListener("mousemove", this.handleMouse);
    window.addEventListener("deviceorientation", this.handleOrientation);
    requestAnimationFrame(this.update);
  }
  /**
   * Event handler to capture screen size
   */
  handleResize(e) {
    this.currWidth = window.innerWidth;
    this.currHeight = window.innerHeight;
  }
  /**
   * Event handler to capture mouse position
   */
  handleMouse(e) {
    this.currMouseX = e.clientX;
    this.currMouseY = e.clientY;
  }
  /**
   * Event handler to capture device orientation
   */
  handleOrientation(e) {
    if (!this.initialAlpha) {
      this.initialAlpha = e.alpha;
    }
    if (!this.initialBeta) {
      this.initialBeta = e.beta;
    }
    if (!this.initialGamma) {
      this.initialGamma = e.gamma;
    }
    this.currAlpha = e.alpha;
    this.currBeta = e.beta;
    this.currGamma = e.gamma;
  }
  /** 
   * Allow initial orientation to be reset to the last recorded values
  */
  recalibrateOrientation() {
    const calibration = {
      prev: {
        alpha: this.initialAlpha,
        beta: this.initialBeta,
        gamma: this.initialGamma
      }
    };
    this.initialAlpha = this.lastAlpha;
    this.initialBeta = this.lastBeta;
    this.initialGamma = this.lastGamma;
    calibration.current = {
      alpha: this.initialAlpha,
      beta: this.initialBeta,
      gamma: this.initialGamma
    };
    return calibration;
  }
  /**
   * Returns a copy of the store data, formatted for public use
   */
  formatData() {
    return {
      scroll: {
        changed: this.scrollChange,
        left: Math.floor(this.lastX),
        right: Math.floor(this.lastX + this.lastWidth),
        top: Math.floor(this.lastY),
        bottom: Math.floor(this.lastY + this.lastHeight),
        velocity: {
          x: Math.floor(this.scrollXVelocity) || 0,
          y: Math.floor(this.scrollYVelocity) || 0
        }
      },
      size: {
        changed: this.sizeChange,
        x: Math.floor(this.lastWidth),
        y: Math.floor(this.lastHeight),
        docY: Math.floor(this.scrollHeight)
      },
      mouse: {
        changed: this.mouseChange,
        x: Math.floor(this.lastMouseX),
        y: Math.floor(this.lastMouseY),
        velocity: {
          x: Math.floor(this.lastMouseXVelocity) || 0,
          y: Math.floor(this.lastMouseYVelocity) || 0
        }
      },
      position: {
        changed: this.positionChange,
        left: Math.floor(this.lastWindowX),
        right: Math.floor(this.lastWindowX + this.lastWidth),
        top: Math.floor(this.lastWindowY),
        bottom: Math.floor(this.lastWindowY + this.lastHeight),
        velocity: {
          x: Math.floor(this.lastWindowXVelocity) || 0,
          y: Math.floor(this.lastWindowYVelocity) || 0
        }
      },
      orientation: {
        changed: this.orientationChange,
        // These values are relative to the first calibrated value
        alpha: Math.floor(this.lastAlpha - this.initialAlpha) || 0,
        beta: Math.floor(this.lastBeta - this.initialBeta) || 0,
        gamma: Math.floor(this.lastGamma - this.initialGamma) || 0
      },
      devicePixelRatio: {
        changed: this.devicePixelRatioChange,
        ratio: this.currDevicePixelRatio
      }
    };
  }
  /**
   * Update function to be looped by requestAnimationFrame
   */
  update() {
    const {
      currWidth,
      currHeight,
      currMouseX,
      currMouseY,
      currAlpha,
      currBeta,
      currGamma,
      currDevicePixelRatio
    } = this;
    if (this.updating) return false;
    this.scrollChange = this.sizeChange = this.mouseChange = this.positionChange = this.orientationChange = this.devicePixelRatioChange = false;
    if (this.windowXVelocity.length > 5) {
      this.windowXVelocity.shift();
    }
    this.windowXVelocity.push(window.screenX - this.lastWindowX);
    if (getMean(this.windowXVelocity) != this.lastWindowXVelocity) {
      this.lastWindowXVelocity = getMean(this.windowXVelocity);
      this.positionChange = true;
    }
    if (window.screenX != this.lastWindowX) {
      this.positionChange = true;
      this.lastWindowX = window.screenX;
    }
    if (this.windowYVelocity.length > 5) {
      this.windowYVelocity.shift();
    }
    this.windowYVelocity.push(window.screenY - this.lastWindowY);
    if (getMean(this.windowYVelocity) != this.lastWindowYVelocity) {
      this.lastWindowYVelocity = getMean(this.windowYVelocity);
      this.positionChange = true;
    }
    if (window.screenY != this.lastWindowY) {
      this.positionChange = true;
      this.lastWindowY = window.screenY;
    }
    if (window.pageXOffset == this.lastX && this.scrollXVelocity != 0) {
      this.scrollXVelocity = 0;
      this.scrollChange = true;
    }
    if (window.pageYOffset == this.lastY && this.scrollYVelocity != 0) {
      this.scrollYVelocity = 0;
      this.scrollChange = true;
    }
    if (window.pageXOffset != this.lastX) {
      this.scrollChange = true;
      this.scrollXVelocity = Math.floor(window.pageXOffset - this.lastX);
      this.lastX = window.pageXOffset;
    }
    if (window.pageYOffset != this.lastY) {
      this.scrollChange = true;
      this.scrollYVelocity = Math.floor(window.pageYOffset - this.lastY);
      this.lastY = window.pageYOffset;
    }
    if (currWidth != this.lastWidth) {
      this.lastWidth = currWidth;
      this.scrollHeight = document.body.scrollHeight;
      this.sizeChange = true;
    }
    if (currHeight != this.lastHeight) {
      this.lastHeight = currHeight;
      this.sizeChange = true;
    }
    if (this.mouseXVelocity.length > 5) {
      this.mouseXVelocity.shift();
    }
    this.mouseXVelocity.push(currMouseX - this.lastMouseX);
    if (getMean(this.mouseXVelocity) != this.lastMouseXVelocity) {
      this.lastMouseXVelocity = getMean(this.mouseXVelocity);
      this.mouseChange = true;
    }
    if (currMouseX != this.lastMouseX) {
      this.lastMouseX = currMouseX;
      this.mouseChange = true;
    }
    if (this.mouseYVelocity.length > 5) {
      this.mouseYVelocity.shift();
    }
    this.mouseYVelocity.push(currMouseY - this.lastMouseY);
    if (getMean(this.mouseYVelocity) != this.lastMouseYVelocity) {
      this.lastMouseYVelocity = getMean(this.mouseYVelocity);
      this.mouseChange = true;
    }
    if (currMouseY != this.lastMouseY || getMean(this.mouseYVelocity) != 0) {
      this.lastMouseY = currMouseY;
      this.mouseChange = true;
    }
    if (currAlpha != this.lastAlpha) {
      this.lastAlpha = currAlpha;
      this.orientationChange = true;
    }
    if (currBeta != this.lastBeta) {
      this.lastBeta = currBeta;
      this.orientationChange = true;
    }
    if (currGamma != this.lastGamma) {
      this.lastGamma = currGamma;
      this.orientationChange = true;
    }
    if (this.positionChange || this.sizeChange) {
      this.currDevicePixelRatio = Math.max(window.devicePixelRatio || 1, 1);
      if (this.currDevicePixelRatio !== this.lastDevicePixelRatio) {
        this.devicePixelRatioChange = true;
        this.lastDevicePixelRatio = this.currDevicePixelRatio;
      }
    }
    if (this.scrollChange || this.sizeChange || this.mouseChange || this.positionChange || this.orientationChange || this.devicePixelRatioChange) {
      this.callbacks.forEach((cb) => cb(this.formatData()));
    }
    this.updating = false;
    requestAnimationFrame(this.update);
  }
  /**
   * Subscribes a function to the 'watched functions' list.
   * Watched functions will be automatically called on update
   * @param {Function} callback The function to call on update
   * @param {Boolean} callOnWatch Call the function on subscribe? defaults to true
   */
  watch(callback, callOnWatch = true) {
    if (typeof callback !== "function") {
      throw new Error("Value passed to Watch is not a function");
    }
    if (isSSR) return;
    if (callOnWatch) {
      const firstRunData = this.formatData();
      firstRunData.scroll.changed = true;
      firstRunData.mouse.changed = true;
      firstRunData.size.changed = true;
      firstRunData.position.changed = true;
      firstRunData.orientation.changed = true;
      firstRunData.devicePixelRatio.changed = true;
      callback(firstRunData);
    }
    this.callbacks.push(callback);
  }
  /**
   * Unsubscribe a function from the 'watched functions' list
   * @param {Function} callback The function to be removed
   */
  unwatch(callback) {
    if (typeof callback !== "function") {
      throw new Error("The value passed to unwatch is not a function");
    }
    if (isSSR) return;
    this.callbacks = this.callbacks.filter((cb) => cb !== callback);
  }
};
var TORNIS = new Tornis();
if (!isSSR) {
  window.__TORNIS = {
    watchViewport: TORNIS.watch,
    unwatchViewport: TORNIS.unwatch,
    getViewportState: TORNIS.formatData,
    recalibrateOrientation: TORNIS.recalibrateOrientation
  };
}
var watchViewport = TORNIS.watch;
var unwatchViewport = TORNIS.unwatch;
var getViewportState = TORNIS.formatData;
var recalibrateOrientation = TORNIS.recalibrateOrientation;
export {
  getViewportState,
  recalibrateOrientation,
  unwatchViewport,
  watchViewport
};
//# sourceMappingURL=tornis.js.map
